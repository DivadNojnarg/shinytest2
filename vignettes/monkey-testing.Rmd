---
title: "Monkey-testing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{monkey-testing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(shinytest2)
library(shiny)
```

# Monkey (headless) testing with `{shinytest2}`

Most people will use `{shinytest2}` with the plug and play `record_test()` app, which is very convenient if you are
not familiar with JavaScript. Under the hood, `record_test()` generates a R script composed of a series of 
instructions that manipulates the app to automate testing on CI/CD environments. 

Monkey testing is widely used by web developers to check the application robustness, particularly in apps with large
number of inputs. The goal is ultimately to try to break the app by triggering unexpected combinations. Most available libraries
are JS-based such as [gremlins.js](https://github.com/marmelab/gremlins.js), traditionally combined with JS-based global testing libraries like [Puppeteer](https://pptr.dev/), but can work with `{shinytest2}` as well. 

In this vignette, we'll provide a more thorough overview of the `AppDriver` R6 class (like for [`{shinytest}`](https://rstudio.github.io/shinytest/articles/in-depth.html)), which allows the developer
to programmatically control the app. We'll see how we can seemlessly benefit from gremlins.js with only few lines of code.

## Initialize the driver

We consider a simple app composed of a slider and a plot output:

```r
ui <- fluidPage(
  sliderInput("obs", "Number of observations:",
    min = 0, max = 1000, value = 500
  ),
  plotOutput("distPlot")
)

# Server logic
server <- function(input, output) {
  output$distPlot <- renderPlot({
    hist(rnorm(input$obs))
  })
}

# Complete app with UI and server components
shinyApp(ui, server)
```

The driver may be initialized with:

```r
headless_app <- AppDriver$new(
  #load_timeout = 10,
  path = "<PATH_TO_APP>",
  name = "monkey-test",
  shiny_args = list(port = 3515)
)
```

Note the `shiny_args` slot allowing you to pass custom options to `shiny::runApp()` such as the port, which
might be useful if your organization restricts port number. `load_timeout` defaults to 10s and 20s locally and during CI/CD, respectively. 
Therefore, if your app takes longer to launch, you can change this value. Keep in mind that an app taking more than 20s to launch is generally
under-optimized and would require specific care such as profiling and refactoring. 

AppDriver starts a Chrome-based headless browser. Interestingly, if you need specific [flags](https://peter.sh/experiments/chromium-command-line-switches/) that are not
available by default in `{shinytest2}`, you can pass them before instantiating the driver:

```r
chromote::set_chrome_args(
  c(
    chromote::default_chrome_args(),
    # Custom flags: see https://peter.sh/experiments/chromium-command-line-switches/
)
```

Some flags are considered by default, particularly `--no-sandbox` which is apply only on CI/CD (Chrome won't start
without) such that you don't need to worry too much about this.

## Injecting gremlins.js

The next steps consists of injecting the gremlins.js dependency in the DOM so that we can unleash the horde.

### Easy way
The easiest way is to call:

```r
headless_app$execute_js("
  (function() {
    var s = document.createElement('script');
    s.src = 'https://unpkg.com/gremlins.js';
    document.body.appendChild(s);
  })();"
)
```

This creates a `script` tag pointing to the right CDN (content delivery network: optimized server to store libraries) and inserts
it at the end of the body.

To test whether everything worked well, we can dump the DOM, look for the scripts. We should be able to find
gremlins.js and try to call `typeof window.gremlins`, which should return an object:

```r
headless_app$get_html("script", outer_html = TRUE)
headless_app$execute_js("return typeof window.gremlins")
```

If `undefined` is returned instead, it means something went wrong. This is generally because the JS code
is clocked by the network. In this case, let's see what we can do in the next part.

### Local way

If you work in a corporate environment chances are you'll end up in this situation. 
A solution is then to store and serve a local copy of the gremlin.js script with `shiny::addResourcePath()`.
Assuming `gremlins.js` are in `inst/js/gremlins.min.js`. Add this to the `app.R` file:

```r
addResourcePath("gremlins", "inst/js/gremlins.min.js")
```

We can subsequently inject the gremlins in the DOM and checks whether everything worked as expected:

```r
headless_app$execute_js("
  (function() {
    var s = document.createElement('script');
    s.src = './gremlins/gremlins.min.js';
    document.body.appendChild(s);
  })();"
)
plop$get_html("script", outer_html = TRUE)
plop$execute_js("return typeof window.gremlins")
```

## Unleash the horde

### A bit about gremlins.js

The workflow is rather simple:

  - We create the horde with `gremlins.createHorde()`.
  - We run the monkey test with `horde.unleash();`. 

```js
const horde = gremlins.createHorde();
horde.unleash();
```

`createHorde()` accepts many species of gremlins capable of handling various events such as
clicks, touch, form filling, scrolling, typing, ... describes in the [documentation](https://github.com/marmelab/gremlins.js#advanced-usage).

As a side note, we don't recommend using the `scroller` which crashes the Chrome instance. 

If your plots rely on random elements like `rnorm`, it is best practice to setup a seed. 
By default, all species will attack in random order with a delay of 10 ms between each event. You can also control the attack strategy to fine tune the global behavior. Finally, if you want more control over what gremlins specie should be doing, you can define a custom specie. 


### Practice

Let's go back to our example. Does it really makes sense to invoke all species given we only have a slider? Absolutely not!
In the following code, we want the clicker gremlin to only click on the element with `id=obs`, that is the slider input.

```js
const customClicker = gremlins.species.clicker({
  // which mouse event types will be triggered
  clickTypes: ['click'],
  // Click only if element has id obs
  canClick: (element) => element.id === 'obs',
  // by default, the clicker gremlin shows its action by a red circle
  // overriding showAction() with an empty function makes the gremlin action invisible
  showAction: (x, y) => {},
});
```

We can create our custom horde, ensuring it is repeatable (random seed) and assuming the clicker specie will 
trigger in 80% of the cases compared to the toucher gremlins:

```js
const horde = gremlins.createHorde({
  randomizer: new gremlins.Chance(1234), // repeatable
  species: [customClicker, gremlins.species.toucher()],
  mogwais: [gremlins.mogwais.alert(), gremlins.mogwais.gizmo()],
  strategies: [
    gremlins.strategies.distribution({
      distribution: [0.8, 0.2], // custom 
      delay: 10 // default
    })
  ]
});
```

Since `unleash` is a promise, we can execute a function right after, to check whether the script ran as expected.

```js
horde
  .unleash()
  .then(() => {
    console.log('Gremlins test success')
});
```

The `console.log` output will be captured by the `{shinytest2}` logs with `headless_app$get_log()` allowing you to debug and refine the 
monkey testing script. 

As Monkey testing lasts about 10s, you often want to take a screenshot of the ongoing attack:

```r
headless_app$execute_js(
  "const customClicker = gremlins.species.clicker({
      // which mouse event types will be triggered
      clickTypes: ['click'],
      // Click only if element has id obs
      canClick: (element) => element.id === 'obs',
      // by default, the clicker gremlin shows its action by a red circle
      // overriding showAction() with an empty function makes the gremlin action invisible
      showAction: (x, y) => {},
    });
    
    gremlins.createHorde({
      randomizer: new gremlins.Chance(1234), // repeatable
      species: [customClicker, gremlins.species.toucher()],
      mogwais: [gremlins.mogwais.alert(),gremlins.mogwais.gizmo()],
      strategies: [
        gremlins.strategies.distribution({
          distribution: [0.8, 0.2], // custom 
          delay: 10 // default
        })
      ]
    }).unleash().then(() => {
      console.log('Gremlins test success')
    });
  "
)

Sys.sleep(3)
headless_app$screenshot("gremlins.png")
```
